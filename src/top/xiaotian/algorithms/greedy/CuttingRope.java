package top.xiaotian.algorithms.greedy;

/**
 * 剑指 Offer 14- I. 剪绳子
 * 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。
 * 请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
 * <p>
 * 示例 1：
 * <p>
 * 输入: 2
 * 输出: 1
 * 解释: 2 = 1 + 1, 1 × 1 = 1
 * 示例 2:
 * <p>
 * 输入: 10
 * 输出: 36
 * 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
 * 提示：
 * <p>
 * 2 <= n <= 58
 */
public class CuttingRope {

  /**
   * 贪心
   * 最高优先级： 3：把绳子尽可能切为多个长度为 3的片段，留下的最后一段绳子的长度可能为 0,1,2三种情况。
   * 次高优先级： 2：若最后一段绳子长度为 2，则保留，不再拆为 1+1 。
   * 最低优先级： 1：若最后一段绳子长度为 1，则应把最后的 3 + 1 替换为 2 + 2，因为 2 * 2 > 3 * 1
   */
  public int cuttingRope(int n) {
    // 当 n ≤ 3 时，按照贪心规则应直接保留原数字，但由于题目要求必须剪成 m (m > 1) 段，因此必须剪出一段长度为 1的绳子，即返回 n - 1。
    if (n <= 3) {
      return n - 1;
    }
    /**
     * 当 n > 3 时，求 n 除以 3 的 整数部分 a 和 余数部分 b（即 n = 3 * a + b），并分为以下三种情况：
     *     当 b = 0 时，直接返回 3 ^ a；
     *     当 b = 1 时，要将一个 1 + 3 转换为 2 + 2，因此返回 3 ^ (a - 1) * 4 ；
     *     当 b = 2 时，保留，返回 3 ^ a * 2
     */
    int a = n / 3;
    int b = n % 3;
    if (b == 0) {
      return (int) Math.pow(3, a);
    } else if (b == 1) {
      return (int) Math.pow(3, a - 1) * 4;
    } else {
      return (int) Math.pow(3, a) * 2;
    }
  }

  // 动态规划
  public int cuttingRope2(int n) {
    /**
     * dp[i] 表示将长度为 i 的绳子剪成至少两段绳子之后，这些绳子长度的最大乘积
     * 当 i = 0, i = 1,不符合条件
     * 当 i = 2, dp[i] = 1
     * 当 i ≥ 2 时，假设对长度为 i 绳子剪出的第一段绳子长度是 j（j: [1, i - 1]），则有以下两种方案：
     *   将 i 剪成 j 和 i-j 长度的绳子，且 i−j 不再继续剪，此时的乘积是 j×(i−j) ；
     *   将 i 剪成 j 和 i−j 长度的绳子，且 i−j 继续剪成多段长度的绳子，此时的乘积是 j×dp[i−j] 。
     * dp[i]=max(j×(i−j),j×dp[i−j])
     */
    int []dp = new int[n + 1];
    dp[2] = 1;
    for (int i = 3; i <= n; i++) {
      for (int j = 1; j <= i - 1; j++) {
        dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
      }
    }
    return dp[n];
  }

}
